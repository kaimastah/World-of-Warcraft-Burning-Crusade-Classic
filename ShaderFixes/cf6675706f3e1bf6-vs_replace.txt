// bar plates / mouse cursor
cbuffer cb2 : register(b2)
{
  float4 cb2[1];
}

cbuffer cb1 : register(b1)
{
  float4 cb1[1];
}

cbuffer cb0 : register(b0)
{
  float4 cb0[5];
}




// 3Dmigoto declarations
#define cmp -
Texture1D<float4> IniParams : register(t120);
Texture2D<float4> StereoParams : register(t125);
Texture2D<float> DepthBuffer : register(t50);

static const float near = 0.0001;
static const float far = 1;

float world_z_from_depth_buffer(float x, float y)
{
    uint width, height;
    float z;

    DepthBuffer.GetDimensions(width, height);

    x = min(max((x / 2 + 0.5) * width, 0), width - 1);
    y = min(max((-y / 2 + 0.5) * height, 0), height - 1);
    z = DepthBuffer.Load(int3(x, y, 0)).x;
    if (z == 1)
        return 0;

  return (far*near/((z)*near) + (far*z));
}

float adjust_from_depth_buffer(float x, float y)
{
    float4 stereo = StereoParams.Load(0);
	float4 iniParams = IniParams.Load(0);
	
	if (stereo.x==0) {return 0;}
    float separation = stereo.x; float convergence = stereo.y;
    float old_offset, offset, w, sampled_w, distance;
    uint i;
	
	// Stereo cursor: To improve the accuracy of the stereo cursor, we
    // sample a number of points on the depth buffer, starting at the near
    // clipping plane and working towards original x + separation.
    //
    // You can think of this as a line in three dimensional space that
    // starts at each eye and stretches out towards infinity. We sample 255
    // points along this line (evenly spaced in the X axis) and compare
    // with the depth buffer to find where the line is first intersected.
    //
    // Note: The reason for sampling 255 points came from a restriction in
    // DX9/SM3 where loops had to run a constant number of iterations and
    // there was no way to set that number from within the shader itself.
    // I'm not sure if the same restriction applies in DX11 with SM4/5 - if
    // it doesn't, we could change this to check each pixel instead for
    // better accuracy.
    //
    // Based on DarkStarSword's stereo crosshair code originally developed
    // for Miasmata, adapted to Unity, then translated to HLSL.

    offset = (near - convergence) * separation; // Z = X offset from center
    distance = separation - offset;         // Total distance to cover (separation - starting X offset)

    old_offset = offset;
    for (i = 0; i < 500; i++) {
        offset += distance / 500.0;

        // Calculate depth for this point on the line:
        w = (separation * convergence * 5) / (separation - offset);

        sampled_w = world_z_from_depth_buffer(x + offset, y);
        if (sampled_w == 0)
            return separation;

        // If the sampled depth is closer than the calculated depth,
        // we have found something that intersects the line, so exit
        // the loop and return the last point that was not intersected:
        if (w > sampled_w)
            break;

        old_offset = offset;
    }

    return old_offset;
}

void main(
  float3 v0 : POSITION0,
  float4 v1 : COLOR0,
  float2 v2 : TEXCOORD0,
  out float4 o0 : SV_POSITION0,
  out float4 o1 : COLOR0,
  out float2 o2 : TEXCOORD0,
  out float2 p2 : TEXCOORD4)
{
  float4 r0,r1,r2;
  uint4 bitmask, uiDest;
  float4 fDest;
  float4 stereo = StereoParams.Load(0);
  float4 iniParams = IniParams.Load(0);
  float4 iniParams1 = IniParams.Load(int2(1,0));

  r0.x = cmp(cb1[0].x != 0.000000);
  r1.xyz = v0.xyz;
  r1.w = 1;
  r2.x = dot(cb0[0].xyzw, r1.xyzw);
  r2.y = dot(cb0[1].xyzw, r1.xyzw);
  r0.yz = float2(1,1) + r2.xy;
  r0.yz = cb0[4].xy * r0.yz;
  r0.yz = float2(0.5,0.5) * r0.yz;
  r0.yz = round(r0.yz);
  r0.yz = r0.yz * float2(2,2) + -cb0[4].xy;
  r0.yz = r0.yz / cb0[4].xy;
  o0.xy = r0.xx ? r0.yz : r2.xy;
  o0.z = dot(cb0[2].xyzw, r1.xyzw);
  o0.w = dot(cb0[3].xyzw, r1.xyzw);
  o1.xyzw = v1.xyzw;
  o2.xy = cb2[0].xy * v2.xy;
  p2.xy = cb2[0].xy;

  if (iniParams.x != 0)
  {
  o0.x+=stereo.x * (1 - stereo.y * iniParams.x);
  }
  
  if (iniParams.w != 0 && iniParams.x != 0 && iniParams1.x == 20 && cb1[0].x == 0.000000)
  {
  o0.x-=stereo.x * (1 - stereo.y * iniParams.x);
  o0.x += adjust_from_depth_buffer(o0.x, o0.y);
  }
  
  else if (iniParams.w != 0 && iniParams.x == 0 && iniParams1.x == 20 && cb1[0].x == 0.000000)
  {
  o0.x += adjust_from_depth_buffer(o0.x, o0.y);
  }

  return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//   using 3Dmigoto v1.3.16 on Wed Aug 28 01:39:43 2019
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// POSITION                 0   xyz         0     NONE   float   xyz
// COLOR                    0   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xy          2     NONE   float   xy
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float   xyzw
// COLOR                    0   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xy          2     NONE   float   xy
// TEXCOORD                 4     zw        2     NONE   float     zw
//
vs_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer cb0[5], immediateIndexed
dcl_constantbuffer cb1[1], immediateIndexed
dcl_constantbuffer cb2[1], immediateIndexed
dcl_input v0.xyz
dcl_input v1.xyzw
dcl_input v2.xy
dcl_output_siv o0.xyzw, position
dcl_output o1.xyzw
dcl_output o2.xy
dcl_output o2.zw
dcl_temps 3
ne r0.x, cb1[0].x, l(0.000000)
mov r1.xyz, v0.xyzx
mov r1.w, l(1.000000)
dp4 r2.x, cb0[0].xyzw, r1.xyzw
dp4 r2.y, cb0[1].xyzw, r1.xyzw
add r0.yz, r2.xxyx, l(0.000000, 1.000000, 1.000000, 0.000000)
mul r0.yz, r0.yyzy, cb0[4].xxyx
mul r0.yz, r0.yyzy, l(0.000000, 0.500000, 0.500000, 0.000000)
round_ne r0.yz, r0.yyzy
mad r0.yz, r0.yyzy, l(0.000000, 2.000000, 2.000000, 0.000000), -cb0[4].xxyx
div r0.yz, r0.yyzy, cb0[4].xxyx
movc o0.xy, r0.xxxx, r0.yzyy, r2.xyxx
dp4 o0.z, cb0[2].xyzw, r1.xyzw
dp4 o0.w, cb0[3].xyzw, r1.xyzw
mov o1.xyzw, v1.xyzw
mul o2.xy, v2.xyxx, cb2[0].xyxx
mov o2.zw, cb2[0].xxxy
ret
// Approximately 0 instruction slots used

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
